[{"categories":["SFML"],"contents":"Basic setting #include \u0026lt;SFML/Graphics.hpp\u0026gt; int main() { const int fieldWidth = 10; const int fieldHeight = 20; sf::Texture yellowTexture; if (!yellowTexture.loadFromFile(\u0026#34;yellow.png\u0026#34;)) { return EXIT_FAILURE; } const int blockWidth = yellowTexture.getSize().x; const int blockHeight = yellowTexture.getSize().y; const int windowWidth = fieldWidth * blockWidth; const int windowHeight = fieldHeight * blockHeight; sf::Sprite yellowSprite(yellowTexture); sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), \u0026#34;Tetris\u0026#34;); while (window.isOpen()) { sf::Event evt; if (window.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { window.close(); } } window.clear(); window.draw(yellowSprite); window.display(); } return EXIT_SUCCESS; } Use Vector2i to present position  pos is dynamic, so no const (唯讀).  const sf::Vector2i origin(fieldWidth/2,0); sf::Vector2i pos(origin);  pos can decide where to be drawn. we can do setPosition before draw it. remember setPosition eats type \u0026ldquo;float\u0026rdquo;.  yellowSprite.setPosition(pos.x*blockWidth, pos.y*blockHeight); Now make the block fall by Clock!!  sf::Clock clock;  if(clock.getEllapsedTime().asSeconds() \u0026gt;=0.3f){ pos.y++; clock.restart(); } Make block stop at the bottom (Detect collision)  Create a vector for nextPos to check. At beginning nextPos is same as pos.  sf::Vector2i nextPos(pos); if(clock.getEllapsedTime().asSeconds() \u0026gt;=0.3f){ nextPos.y++; clock.restart(); } //* However, we need to examine whether can have nextPos if(nextPos.x \u0026gt;0 \u0026amp;\u0026amp; nextPos.x \u0026lt; fieldWidth \u0026amp;\u0026amp; nextPos.y \u0026lt; fieldHeight){ pos = nextPos; } Define what user do enum class Action{ Hold, MoveDown, MoveLeft, MoveRight, }; Action action = Action::Hold;  Default action : Hold. Use switch to determine actions. Check whether the keyboard is pressed.  switch (action) { case Action::Hold: break; case Action::MoveDown: nextPos.y++; break; case Action::MoveLeft: nextPos.x--; break; case Action::MoveRight: nextPos.x++; break; } if (evt.type == sf::Event::KeyPressed) { switch (evt.key.code) { case sf::Keyboard::Left: action = Action::MoveLeft; break; case sf::Keyboard::Right: action = Action::MoveRight; break; } } We want to make the block back to top when hit the bottom. if (nextPos.x \u0026gt; 0 \u0026amp;\u0026amp; nextPos.x \u0026lt; fieldWidth \u0026amp;\u0026amp; nextPos.y \u0026lt; fieldHeight) { pos = nextPos; }// if nextPos is not vaild \telse { if (action == Action::MoveDown) { pos = origin; //let pos become origin, when hit the bottom. \t} } ","permalink":"https://ycl818.github.io/blog/sfml5/","tags":["codings"],"title":"SFML 5"},{"categories":["SFML"],"contents":" When you include #include \u0026lt;SFML/Graphics.hpp\u0026gt;, you can start to use the classRenderwindow to create object. While window is opening, the program keep running, otherwise this program is done. In order to interact with user, we use window.pollEvent(evt), evt is a local variable which is an object of class sf::Event. For example, the event is \u0026ldquo;Close the window\u0026rdquo;, then we close the window. However, we still cannot create a reeal window, because we haven\u0026rsquo;t give it a suitable size. As a result, we give window two parameters one called mode, the other called title. mode is an object of class VideoMode, and we give mode two parameters windowHeight and windowWidth. How can we decide? windowHeight and windowWidth. title is an object of class in the sf::String, we can give it a namee directly.  We want to create a window with texture\u0026rsquo;s size  we can use sf::Texture to load figure. name an object blockTexture and use loadFromfile(\u0026quot;block.png\u0026quot;).  const int fieldWidth = 6; const int fieldHeight = 10; sf::Texture blockTexture; blockTexture.loadFromFile(\u0026#34;block.png\u0026#34;); sf::Vector2u blockSize(blockTexture.getSize()); const int windowWidth = blockSize.x * fieldWidth; const int windowHeight = blockSize.y * fieldHeight;   Then, we start to draw\nstep1 : window.clear(). step2 : window.draw(). step3 : window.display().\n  use Texture to construct sf::Sprite.\n  #include \u0026lt;SFML/Graphics.hpp\u0026gt; int main() { const int fieldWidth = 6; const int fieldHeight = 10; sf::Texture blockTexture; blockTexture.loadFromFile(\u0026#34;block.png\u0026#34;); sf::Vector2u blockSize(blockTexture.getSize()); const int windowWidth = blockSize.x * fieldWidth; const int windowHeight = blockSize.y * fieldHeight; sf::String title(\u0026#34;Line Match\u0026#34;); sf::VideoMode mode(windowWidth, windowHeight); sf::RenderWindow window(mode, title); sf::Sprite block(blockTexture); while (window.isOpen()) { sf::Event evt; if (window.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { window.close(); } } window.clear(); window.draw(block); window.display(); } return EXIT_SUCCESS; } We want to make the block fall in the middle of field sf::Sprite block(blockTexture); block.setPosition();  mention that func setPosition() eats \u0026ldquo;float\u0026rdquo; type.  block.setPosition(float(fieldWidth/2*blockSize.x), 0.0f);\nUse class Clock to calculate time  If the elapsed time is counted in seconds \u0026gt;=0.5 second, we restart it. How to make the block fall?  we need to set position, then we need to know the original position first.\n we use Vector2i to remember the original position.  #include \u0026lt;SFML/Graphics.hpp\u0026gt; int main() { const int fieldWidth = 6; const int fieldHeight = 10; sf::Texture blockTexture; blockTexture.loadFromFile(\u0026#34;block.png\u0026#34;); sf::Vector2u blockSize(blockTexture.getSize()); const int windowWidth = blockSize.x * fieldWidth; const int windowHeight = blockSize.y * fieldHeight; sf::String title(\u0026#34;Line Match\u0026#34;); sf::VideoMode mode(windowWidth, windowHeight); sf::RenderWindow window(mode, title); sf::Sprite block(blockTexture); sf::Vector2i pos(fieldWidth / 2, 0); block.setPosition(float(pos.x*blockSize.x), float(pos.y*blockSize.y)); sf::Clock clock; while (window.isOpen()) { sf::Event evt; if (window.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { window.close(); } } if (clock.getElapsedTime().asSeconds() \u0026gt;= 0.5f) { pos.y++; block.setPosition(float(pos.x * blockSize.x), float(pos.y * blockSize.y)); clock.restart(); } window.clear(); window.draw(block); window.display(); } return EXIT_SUCCESS; } Use function to package common program fragments #include \u0026lt;SFML/Graphics.hpp\u0026gt;sf::Vector2f getPixelPosition( const sf::Vector2i\u0026amp; pos, const sf::Vector2u\u0026amp; blockSize) { return sf::Vector2f(float(pos.x * blockSize.x), float(pos.y * blockSize.y)); } int main() { const int fieldWidth = 6; const int fieldHeight = 10; sf::Texture blockTexture; blockTexture.loadFromFile(\u0026#34;block.png\u0026#34;); sf::Vector2u blockSize(blockTexture.getSize()); const int windowWidth = blockSize.x * fieldWidth; const int windowHeight = blockSize.y * fieldHeight; sf::String title(\u0026#34;Line Match\u0026#34;); sf::VideoMode mode(windowWidth, windowHeight); sf::RenderWindow window(mode, title); sf::Sprite block(blockTexture); sf::Vector2i pos(fieldWidth / 2, 0); block.setPosition(getPixelPosition(pos, blockSize)); sf::Clock clock; while (window.isOpen()) { sf::Event evt; if (window.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { window.close(); } } if (clock.getElapsedTime().asSeconds() \u0026gt;= 0.5f) { pos.y++; block.setPosition(getPixelPosition(pos, blockSize)); clock.restart(); } window.clear(); window.draw(block); window.display(); } return EXIT_SUCCESS; } Add KeyPressed event if (evt.type == sf::Event::KeyPressed) { if (evt.key.code == sf::Keyboard::Left) { pos.x--; } if (evt.key.code == sf::Keyboard::Right) { pos.x++; } } Avoid actions happen at the same time  Use enum to control action  enum class action { Hold, MoveLeft, MoveRight, MoveDown, };  The default is immobile  #include \u0026lt;SFML/Graphics.hpp\u0026gt;sf::Vector2f getPixelPosition( const sf::Vector2i\u0026amp; pos, const sf::Vector2u\u0026amp; blockSize) { return sf::Vector2f(float(pos.x * blockSize.x), float(pos.y * blockSize.y)); } int main() { const int fieldWidth = 6; const int fieldHeight = 10; sf::Texture blockTexture; blockTexture.loadFromFile(\u0026#34;block.png\u0026#34;); sf::Vector2u blockSize(blockTexture.getSize()); const int windowWidth = blockSize.x * fieldWidth; const int windowHeight = blockSize.y * fieldHeight; sf::String title(\u0026#34;Line Match\u0026#34;); sf::VideoMode mode(windowWidth, windowHeight); sf::RenderWindow window(mode, title); sf::Sprite block(blockTexture); sf::Vector2i pos(fieldWidth / 2, 0); block.setPosition(getPixelPosition(pos, blockSize)); sf::Clock clock; while (window.isOpen()) { enum class Action { Hold, MoveLeft, MoveRight, MoveDown, }; Action action = Action::Hold; sf::Event evt; if (window.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { window.close(); } if (evt.type == sf::Event::KeyPressed) { if (evt.key.code == sf::Keyboard::Left) { action = Action::MoveLeft; } if (evt.key.code == sf::Keyboard::Right) { action = Action::MoveRight; } } } if (clock.getElapsedTime().asSeconds() \u0026gt;= 0.5f) { action = Action::MoveDown; clock.restart(); } switch (action) { case Action::Hold: break; case Action::MoveLeft: pos.x--; break; case Action::MoveRight: pos.x++; break; case Action::MoveDown: pos.y++; break; } window.clear(); block.setPosition(getPixelPosition(pos, blockSize)); window.draw(block); window.display(); } return EXIT_SUCCESS; } Aviod the block outside of window  At the beginning, nextPos is same as origin pos. When you really want to update pos, then copy back to pos.  sf::Vector2i nextPos = pos; switch (action) { case Action::Hold: break; case Action::MoveLeft: nextPos.x--; break; case Action::MoveRight: nextPos.x++; break; case Action::MoveDown: nextPos.y++; break; } if (nextPos.x \u0026gt;= 0 \u0026amp;\u0026amp; nextPos.x \u0026lt; fieldWidth \u0026amp;\u0026amp; nextPos.y \u0026lt; fieldHeight) { pos = nextPos; } When the block outside of window, back to original place. sf::Vector2i origin(fieldWidth / 2, 0); sf::Vector2i pos(origin); if (nextPos.x \u0026gt;= 0 \u0026amp;\u0026amp; nextPos.x \u0026lt; fieldWidth \u0026amp;\u0026amp; nextPos.y \u0026lt; fieldHeight) { pos = nextPos; } else { pos = origin; }  add condition that only when going Down outside of window will back to original place.  if (nextPos.x \u0026gt;= 0 \u0026amp;\u0026amp; nextPos.x \u0026lt; fieldWidth \u0026amp;\u0026amp; nextPos.y \u0026lt; fieldHeight) { pos = nextPos; } else { if (action == Action::MoveDown) { pos = origin; } } Create Bool field to detect block. bool field[fieldWidth][fieldHeight] = {}; //[F,F,F,F,F,F] \t//[F,F,F,F,F,F] \t//[F,F,F,F,F,F] \t//[F,F,F,F,F,F] \t//[F,F,F,F,F,F] \t//[F,F,F,F,F,F] \t//[F,F,F,F,F,F] \t//[F,F,F,F,F,F] \t//[F,F,F,F,F,F] \t//[F,F,F,F,F,F]  set a record, imagin that the block becomes a barrier.  if (nextPos.x \u0026gt;= 0 \u0026amp;\u0026amp; nextPos.x \u0026lt; fieldWidth \u0026amp;\u0026amp; nextPos.y \u0026lt; fieldHeight) { pos = nextPos; } else { if (action == Action::MoveDown) { field[pos.x][pos.y] == true; pos = origin; } }  draw field  // current controling block \tblock.setPosition(getPixelPosition(pos, blockSize)); window.draw(block); // draw the field \tfor (int x = 0; x \u0026lt; fieldWidth; x++) { for (int y = 0; y \u0026lt; fieldHeight; y++) { if (field[x][y] == true) { sf::Vector2i p(x, y); block.setPosition(getPixelPosition(p, blockSize)); window.draw(block); } } }  add condition: check the field contain a barrier or not.  if nothing ther, we can go next.\nif (nextPos.x \u0026gt;= 0 \u0026amp;\u0026amp; nextPos.x \u0026lt; fieldWidth \u0026amp;\u0026amp; nextPos.y \u0026lt; fieldHeight \u0026amp;\u0026amp; field[nextPos.x][nextPos.y]==false) { pos = nextPos; } Create barriers in the field for (int y = 3; y \u0026lt; fieldHeight; y++) { for (int k = 1; k \u0026lt; 3;k++) { field[rand() % fieldWidth][y] = true; } } whether there is a line full of block?  It is possible to fill up a line only when the field changes  if (nextPos.x \u0026gt;= 0 \u0026amp;\u0026amp; nextPos.x \u0026lt; fieldWidth \u0026amp;\u0026amp; nextPos.y \u0026lt; fieldHeight \u0026amp;\u0026amp; field[nextPos.x][nextPos.y]==false) { pos = nextPos; } else { if (action == Action::MoveDown) { field[pos.x][pos.y] = true; // check pos.y line is full of blocks or not \tbool isFull = true; for (int x = 0; x \u0026lt; fieldWidth;x++) { if (field[x][pos.y] == false) { isFull = false; } } if (isFull) { // Move all the rows above pos.y down one line \tfor (int y = pos.y; y \u0026gt; 0 ;y--) { for (int x = 0; x \u0026lt; fieldWidth;x++) { field[x][y] = field[x][y - 1]; } } for (int x = 0; x \u0026lt; fieldWidth;x++) { field[x][0] = false; } } pos = origin; } } ","permalink":"https://ycl818.github.io/blog/sfml4/","tags":["codings"],"title":"SFML 4"},{"categories":["SFML"],"contents":"SFML Notes #include \u0026lt;SFML/Graphics.hpp\u0026gt;#include \u0026lt;iostream\u0026gt;int main() { int fieldWidth = 20; int fieldHeight = 15; sf::Texture blocktexture; if (!blocktexture.loadFromFile(\u0026#34;block.png\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;block.png is not found\u0026#34; \u0026lt;\u0026lt; std::endl; return EXIT_FAILURE; } sf::Sprite block(blocktexture); float blockWidth = block.getLocalBounds().width; float blockHeight = block.getLocalBounds().height; sf::VideoMode mode( unsigned int(fieldWidth * blockWidth), unsigned int(fieldHeight * blockHeight)); sf::RenderWindow w(mode, \u0026#34;Snake_Game\u0026#34;); while (w.isOpen()) { sf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { w.close(); } } w.clear(); for (int i = 0; i \u0026lt; fieldWidth; i++) { for (int j = 0; j \u0026lt; fieldHeight; j++) { block.setPosition(i * blockWidth, j* blockHeight); w.draw(block); } } w.display(); } return EXIT_SUCCESS; } sf::Vector2 #include \u0026lt;SFML/Graphics.hpp\u0026gt;#include \u0026lt;iostream\u0026gt;int main() { sf::Vector2\u0026lt;int\u0026gt; fieldSize(20, 15); sf::Texture blocktexture; if (!blocktexture.loadFromFile(\u0026#34;block.png\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;block.png is not found\u0026#34; \u0026lt;\u0026lt; std::endl; return EXIT_FAILURE; } sf::Sprite block(blocktexture); sf::Vector2\u0026lt;float\u0026gt; blockSize( block.getLocalBounds().width, block.getLocalBounds().height); sf::VideoMode mode( unsigned int(fieldSize.x * blockSize.x), unsigned int(fieldSize.y * blockSize.y)); sf::RenderWindow w(mode, \u0026#34;Snake_Game\u0026#34;); while (w.isOpen()) { sf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { w.close(); } } w.clear(); for (int i = 0; i \u0026lt; fieldSize.x; i++) { for (int j = 0; j \u0026lt; fieldSize.y; j++) { sf::Vector2\u0026lt;float\u0026gt; pos( i * blockSize.x, j * blockSize.y ); block.setPosition(pos.x,pos.y); //block.setPosition(pos) is fine too. \tw.draw(block); } } w.display(); } return EXIT_SUCCESS; } typedef and Using #include \u0026lt;SFML/Graphics.hpp\u0026gt;#include \u0026lt;iostream\u0026gt;int main() { typedef sf::Vector2i V2i; typedef sf::Texture Tex; //using V2i = sf::Vector2i; \t//using Tex = sf::Texture; \tV2i fieldSize(20, 15); Tex blocktexture; if (!blocktexture.loadFromFile(\u0026#34;block.png\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;block.png is not found\u0026#34; \u0026lt;\u0026lt; std::endl; return EXIT_FAILURE; } sf::Sprite block(blocktexture); sf::Vector2\u0026lt;float\u0026gt; blockSize( block.getLocalBounds().width, block.getLocalBounds().height); sf::VideoMode mode( unsigned int(fieldSize.x * blockSize.x), unsigned int(fieldSize.y * blockSize.y)); sf::RenderWindow w(mode, \u0026#34;Snake_Game\u0026#34;); while (w.isOpen()) { sf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { w.close(); } } w.clear(); for (int i = 0; i \u0026lt; fieldSize.x; i++) { for (int j = 0; j \u0026lt; fieldSize.y; j++) { sf::Vector2f pos( i * blockSize.x, j * blockSize.y ); block.setPosition(pos.x,pos.y); //block.setPosition(pos) is fine too. \tw.draw(block); } } w.display(); } return EXIT_SUCCESS; } Add head in specific position. #include \u0026lt;SFML/Graphics.hpp\u0026gt;#include \u0026lt;iostream\u0026gt;int main() { sf::Vector2i fieldSize(20, 15); sf::Texture blocktexture; if (!blocktexture.loadFromFile(\u0026#34;block.png\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;block.png is not found\u0026#34; \u0026lt;\u0026lt; std::endl; return EXIT_FAILURE; } sf::Vector2i head(3, 4); sf::Sprite block(blocktexture); sf::Vector2\u0026lt;float\u0026gt; blockSize( block.getLocalBounds().width, block.getLocalBounds().height); sf::VideoMode mode( unsigned int(fieldSize.x * blockSize.x), unsigned int(fieldSize.y * blockSize.y)); sf::RenderWindow w(mode, \u0026#34;Snake_Game\u0026#34;); while (w.isOpen()) { sf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { w.close(); } } w.clear(); sf::Vector2f pos( head.x * blockSize.x, head.y * blockSize.y);\tblock.setPosition(pos.x,pos.y); w.draw(block); w.display(); } return EXIT_SUCCESS; }  setFrameRateLimit : control pins  w.setFramerateLimit(1); while (w.isOpen()) { // interact with user events /detecting and processing \tsf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { w.close(); } } //move object \thead.x += 1; //draw  w.clear(); sf::Vector2f pos( head.x * blockSize.x, head.y * blockSize.y);\tblock.setPosition(pos.x,pos.y); w.draw(block); w.display(); } return EXIT_SUCCESS;  However this is not good, when you are swiping window, you will feel disconnected.  Because the roop run in 1 sec a time. We hope that detecing,processing and drawing keep continue.\nSolution by using Clock sf::Clock clock; while (w.isOpen()) { // interact with user events /detecting and processing \tsf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { w.close(); } } //move object  if (clock.getElapsedTime().asSeconds() \u0026gt;= 1.0f) { head.x += 1; clock.restart(); } //draw  w.clear(); sf::Vector2f pos( head.x * blockSize.x, head.y * blockSize.y);\tblock.setPosition(pos.x,pos.y); w.draw(block); w.display(); } return EXIT_SUCCESS; Add keyboard events #include \u0026lt;SFML/Graphics.hpp\u0026gt;#include \u0026lt;iostream\u0026gt;int main() { sf::Vector2i fieldSize(20, 15); sf::Texture blocktexture; if (!blocktexture.loadFromFile(\u0026#34;block.png\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;block.png is not found\u0026#34; \u0026lt;\u0026lt; std::endl; return EXIT_FAILURE; } sf::Vector2i head(3, 4); sf::Sprite block(blocktexture); sf::Vector2\u0026lt;float\u0026gt; blockSize( block.getLocalBounds().width, block.getLocalBounds().height); sf::VideoMode mode( unsigned int(fieldSize.x * blockSize.x), unsigned int(fieldSize.y * blockSize.y)); sf::RenderWindow w(mode, \u0026#34;Snake_Game\u0026#34;); enum class Direction {UP,DOWN,LEFT,RIGHT}; Direction direction = Direction::RIGHT; sf::Clock clock; while (w.isOpen()) { sf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { w.close(); } if (evt.type == sf::Event::KeyPressed) { if (evt.key.code == sf::Keyboard::Up) { direction = Direction::UP; } if (evt.key.code == sf::Keyboard::Down) { direction = Direction::DOWN; } if (evt.key.code == sf::Keyboard::Left) { direction = Direction::LEFT; } if (evt.key.code == sf::Keyboard::Right) { direction = Direction::RIGHT; } } } if (clock.getElapsedTime().asSeconds() \u0026gt;= 1.0f) { if (direction == Direction::UP) { head.y--; } if (direction == Direction::DOWN) { head.y++; } if (direction == Direction::LEFT) { head.x--; } if (direction == Direction::RIGHT) { head.x++; } clock.restart(); } w.clear(); sf::Vector2f pos( head.x * blockSize.x, head.y * blockSize.y);\tblock.setPosition(pos.x,pos.y); w.draw(block); w.display(); } return EXIT_SUCCESS; Add food sf::Vector2i food(rand()%fieldSize.x, rand()%fieldSize.y); w.clear(); //draw head \tsf::Vector2f headPos( head.x * blockSize.x, head.y * blockSize.y);\tblock.setPosition(headPos.x,headPos.y); w.draw(block); //draw food \tsf::Vector2f foodPos( food.x* blockSize.x, food.y* blockSize.y); block.setPosition(foodPos.x, foodPos.y); w.draw(block); Add body to snake (full version)\n#include \u0026lt;SFML/Graphics.hpp\u0026gt;#include \u0026lt;iostream\u0026gt;int main() { sf::Vector2i fieldSize(20, 15); sf::Texture blocktexture; if (!blocktexture.loadFromFile(\u0026#34;block.png\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;block.png is not found\u0026#34; \u0026lt;\u0026lt; std::endl; return EXIT_FAILURE; } std::vector\u0026lt;sf::Vector2i\u0026gt; snake = { sf::Vector2i(3,4) }; sf::Vector2i food(rand()%fieldSize.x, rand()%fieldSize.y); sf::Sprite block(blocktexture); sf::Vector2\u0026lt;float\u0026gt; blockSize( block.getLocalBounds().width, block.getLocalBounds().height); sf::VideoMode mode( unsigned int(fieldSize.x * blockSize.x), unsigned int(fieldSize.y * blockSize.y)); sf::RenderWindow w(mode, \u0026#34;Snake_Game\u0026#34;); enum class Direction {UP,DOWN,LEFT,RIGHT}; Direction direction = Direction::RIGHT; sf::Clock clock; while (w.isOpen()) { sf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { w.close(); } if (evt.type == sf::Event::KeyPressed) { if (evt.key.code == sf::Keyboard::Up) { direction = Direction::UP; } if (evt.key.code == sf::Keyboard::Down) { direction = Direction::DOWN; } if (evt.key.code == sf::Keyboard::Left) { direction = Direction::LEFT; } if (evt.key.code == sf::Keyboard::Right) { direction = Direction::RIGHT; } } } if (clock.getElapsedTime().asSeconds() \u0026gt;= 1.0f) { // snake = {(3,4)} \t// head = (3,4) \tsf::Vector2i head = snake[0]; //moving of object \tif (direction == Direction::UP) { head.y--; } if (direction == Direction::DOWN) { head.y++; } if (direction == Direction::LEFT) { head.x--; } if (direction == Direction::RIGHT) { head.x++; } // head(4,4) \tsnake.insert(snake.begin(), head); // snake = {(4,4),(3,4)}  sn // Has food eaten by snake? \tif (food == head) { std::cout \u0026lt;\u0026lt; \u0026#34;Eaten\u0026#34; \u0026lt;\u0026lt; std::endl; } clock.restart(); } w.clear(); //draw snake \tfor (const sf::Vector2i\u0026amp; body : snake) { sf::Vector2f bodyPos( body.x * blockSize.x, body.y * blockSize.y); block.setPosition(bodyPos); w.draw(block); } //draw food \tsf::Vector2f foodPos( food.x* blockSize.x, food.y* blockSize.y); block.setPosition(foodPos.x, foodPos.y); w.draw(block); w.display(); } return EXIT_SUCCESS; } Add isDead bool, dead color, and if not dead to do #include \u0026lt;SFML/Graphics.hpp\u0026gt;#include \u0026lt;iostream\u0026gt;int main() { sf::Vector2i fieldSize(20, 15); sf::Texture blocktexture; if (!blocktexture.loadFromFile(\u0026#34;block.png\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;block.png is not found\u0026#34; \u0026lt;\u0026lt; std::endl; return EXIT_FAILURE; } std::vector\u0026lt;sf::Vector2i\u0026gt; snake = { sf::Vector2i(3,4) }; sf::Vector2i food(rand()%fieldSize.x, rand()%fieldSize.y); sf::Sprite block(blocktexture); sf::Vector2\u0026lt;float\u0026gt; blockSize( block.getLocalBounds().width, block.getLocalBounds().height); sf::VideoMode mode( unsigned int(fieldSize.x * blockSize.x), unsigned int(fieldSize.y * blockSize.y)); sf::RenderWindow w(mode, \u0026#34;Snake_Game\u0026#34;); enum class Direction {UP,DOWN,LEFT,RIGHT}; Direction direction = Direction::RIGHT; sf::Clock clock; bool isDead = false; while (w.isOpen()) { sf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { w.close(); } if (evt.type == sf::Event::KeyPressed) { if (evt.key.code == sf::Keyboard::Up) { direction = Direction::UP; } if (evt.key.code == sf::Keyboard::Down) { direction = Direction::DOWN; } if (evt.key.code == sf::Keyboard::Left) { direction = Direction::LEFT; } if (evt.key.code == sf::Keyboard::Right) { direction = Direction::RIGHT; } } } if (clock.getElapsedTime().asSeconds() \u0026gt;= 0.4f) { // snake = {(3,4)} \t// head = (3,4) \tsf::Vector2i head = snake[0]; //moving of object \tif (direction == Direction::UP) { head.y--; } if (direction == Direction::DOWN) { head.y++; } if (direction == Direction::LEFT) { head.x--; } if (direction == Direction::RIGHT) { head.x++; } if (head.x \u0026lt; 0 || head.x \u0026gt;= fieldSize.x || head.y \u0026lt; 0 || head.y \u0026gt;= fieldSize.y) { isDead = true; } if (!isDead) { // Has food eaten by snake? \tif (food == head) { std::cout \u0026lt;\u0026lt; \u0026#34;Eaten\u0026#34; \u0026lt;\u0026lt; std::endl; } else { snake.pop_back(); } snake.insert(snake.begin(), head); } clock.restart(); } if (isDead) { w.clear(sf::Color::Red); } else { w.clear(); } //draw snake \tfor (const sf::Vector2i\u0026amp; body : snake) { sf::Vector2f bodyPos( body.x * blockSize.x, body.y * blockSize.y); block.setPosition(bodyPos); w.draw(block); } //draw food \tsf::Vector2f foodPos( food.x* blockSize.x, food.y* blockSize.y); block.setPosition(foodPos.x, foodPos.y); w.draw(block); w.display(); } return EXIT_SUCCESS; } ","permalink":"https://ycl818.github.io/blog/sfml3/","tags":["codings"],"title":"SFML 3"},{"categories":["SFML"],"contents":"//this will have warning double =\u0026gt; float text.move(0.01, 0); // func move needs two parameters (float, float)  //slove by added \u0026#39;f\u0026#39; text.move(0.01f, 0); text.move(0.01f, 0.f); // going left text.move(-0.01f, 0.f); #include \u0026lt;SFML/Window.hpp\u0026gt;#include \u0026lt;SFML/Graphics.hpp\u0026gt;int main(){ sf::Font font; if(font.loadFromFile(\u0026#34;arial.ttf\u0026#34;) == false ){ return EXIT_FAILURE; } int LEFT_TO_RIGHT = 0; int RIGHT_TO_LEFT = 1; int direction = RIGHT_TO_LEFT; //0: LEFT_TO_RIGHT 1:RIGHT_TO_LEFT  sf::Text text(\u0026#34;Hello\u0026#34;, font); sf::RenderWindow w(sf::VideoMode(400, 200), \u0026#34;Hello\u0026#34;); if (direction ==1){ text.setPosition((float)( w.getSize().x) , 0 } while(w.isOpen()){ sf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { std::cout \u0026lt;\u0026lt; \u0026#34;close\u0026#34; \u0026lt;\u0026lt; std::endl; w.close(); } } w.clear(); w.draw(text); w.display(); switch(direction){ case LEFT_TO_RIGHT: text.move(0.01f,0); break; case RIGHT_TO_LEFT: text.move(-0.01f,0); break; } } return EXIT_SUCCESS; }  text.setPosition this func needs (float, float)  so when we use w.getSize().x change \u0026lsquo;int\u0026rsquo; to \u0026lsquo;float\u0026rsquo; are needed.\nC style transform : text.setPosition((float)( w.getSize().x) , 0)\n  int direction = 0; //0: LEFT_TO_RIGHT 1:RIGHT_TO_LEFT to make code more flexible\n  case LEFT_TO_RIGHT: switch case only accept constant.\n  So, if we want to let ' LEFT_TO_RIGHT' can be use, we need to declare \u0026lsquo;const\u0026rsquo; when we declare the variable.\n we can use enum {LEFT_TO_RIGHT, RIGHT_TO_LEFT} to instead of declaring \u0026lsquo;int\u0026rsquo;.  because we only need to ensure these two directions have different values.\nAdd Speed , same method as direction. switch (direction) { case LEFT_TO_RIGHT: if (speed == FAST) { text.move(0.1f, 0); } if (speed == SLOW) { text.move(0.01f, 0); } break; case RIGHT_TO_LEFT: if (speed == FAST) { text.move(-0.1f, 0); } if (speed == SLOW) { text.move(-0.01f, 0); } break; } Improvement float diff; switch (speed) { case FAST: diff = 0.1f; break; case SLOW: diff = 0.01f; break; } switch (direction) { case LEFT_TO_RIGHT: text.move(diff, 0); break; case RIGHT_TO_LEFT: text.move(-diff, 0); break; } Problem  Here comes a question: we use two \u0026ldquo;enum\u0026rdquo;  enum {LEFT_TO_RIGHT, RIGHT_TO_LEFT}; enum {FAST, SLOW}; Both values of them are 0 and 1. This may cause confusion.\nSolution  Give enum \u0026ldquo;types\u0026rdquo;, in other words, give them names.  enum Direction {LEFT_TO_RIGHT, RIGHT_TO_LEFT}; enum Speed {FAST, SLOW};\n To avoid name collision, we can give enum class  enum class Direction {LEFT_TO_RIGHT, RIGHT_TO_LEFT}; enum class Speed {FAST, SLOW};\nSo that, we need to declare its class to use.\nSpeed speed = Speed::SLOW;\nDirection direction = Direction::RIGHT_TO_LEFT;\n#include \u0026lt;SFML/Window.hpp\u0026gt;#include \u0026lt;SFML/Graphics.hpp\u0026gt; int main() { sf::Font font; if (font.loadFromFile(\u0026#34;arial.ttf\u0026#34;) == false) { return EXIT_FAILURE; } enum class Direction { LEFT_TO_RIGHT, RIGHT_TO_LEFT }; enum class Speed {FAST, SLOW}; Speed speed = SLOW; Direction direction = RIGHT_TO_LEFT; //0: LEFT_TO_RIGHT 1:RIGHT_TO_LEFT  sf::Text text(\u0026#34;Hello\u0026#34;, font); sf::RenderWindow w(sf::VideoMode(400, 200), \u0026#34;Hello\u0026#34;); if (direction == 1) { text.setPosition((float)(w.getSize().x), 0); } while (w.isOpen()) { sf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { w.close(); } } w.clear(); w.draw(text); w.display(); float diff; switch (speed) { case FAST: diff = 0.1f; break; case SLOW: diff = 0.01f; break; } switch (direction) { case LEFT_TO_RIGHT: text.move(diff, 0); break; case RIGHT_TO_LEFT: text.move(-diff, 0); break; } } return EXIT_SUCCESS; } Add key event, draw circles, and speed up #include \u0026lt;SFML/Window.hpp\u0026gt;#include \u0026lt;SFML/Graphics.hpp\u0026gt; int main() { srand sf::Font font; if (font.loadFromFile(\u0026#34;arial.ttf\u0026#34;) == false) { return EXIT_FAILURE; } enum class Direction{ LEFT_TO_RIGHT, RIGHT_TO_LEFT }; enum class Speed {FAST, SLOW}; Direction direction = Direction::LEFT_TO_RIGHT; Speed speed = Speed::SLOW; sf::Text text(\u0026#34;Hello\u0026#34;, font,200); text.setFillColor(sf::Color(0, 255, 0)); sf::CircleShape circle(2); circle.setFillColor(sf::Color(0, 0, 0)); sf::RenderWindow w(sf::VideoMode(500, 250), \u0026#34;Hello\u0026#34;); if (direction == Direction::RIGHT_TO_LEFT) { text.setPosition((float)(w.getSize().x), 0); } while (w.isOpen()) { sf::Event evt; if (w.pollEvent(evt)) { if (evt.type == sf::Event::Closed) { w.close(); } if (evt.type == sf::Event::KeyPressed) { if (evt.key.code == sf::Keyboard::Key::Left) { direction = Direction::LEFT_TO_RIGHT; } if (evt.key.code == sf::Keyboard::Key::Right) { direction = Direction::RIGHT_TO_LEFT; } } } w.clear(); w.draw(text); for (unsigned int i = 0; i \u0026lt; w.getSize().x; i += 4) { for (unsigned int j = 0; j \u0026lt; w.getSize().y; j += 4) { circle.setPosition(float(i), float(j)); w.draw(circle); } } w.display(); float diff; switch (speed) { case Speed::FAST: diff = 0.1f * 40; break; case Speed::SLOW: diff = 0.01f *40; break; } switch (direction) { case Direction::LEFT_TO_RIGHT: text.move(diff, 0); break; case Direction::RIGHT_TO_LEFT: text.move(-diff, 0); break; } } return EXIT_SUCCESS; } ","permalink":"https://ycl818.github.io/blog/sfml2/","tags":["codings"],"title":"SFML 2"},{"categories":["SFML"],"contents":"SFML Notes  為了幫助記憶 SFML documents\n 中文是寬字元 \u0026quot;\u0026quot; 前面要加 L =\u0026gt; L\u0026quot;我的中文\u0026quot;\n 視窗標題是系統的字形 內文字型要顯示中文 要load中文字形   std 為命名空間(namespace) cout , endl //識別符(identifier) 宣告定義完才能使用 int, if, for //關鍵字(keyword)  #include \u0026lt;iostream\u0026gt; // iostream: 標頭檔(head file) int main(){ std::cout \u0026lt;\u0026lt; \u0026#34;Hello World \u0026#34; \u0026lt;\u0026lt;std::endl; } #include \u0026lt;SFML/Window.hpp\u0026gt;int main(){ int x = 10; // int =\u0026gt;type  sf::VideoMode mode(400, 200) //sf::VideoMode::VideoMode(?,?)  sf::String title(\u0026#34;Hello\u0026#34;); //const(唯讀) String \u0026amp;(參考代表不複製)  sf::Window w(mode,title); // class =\u0026gt; type  while(true){ } return 0; }  x 為整數物件的變數 w 是一個window物件的變數 when you create object \u0026lsquo;w\u0026rsquo;\nDefault=\u0026gt; sf::Window::Window() : 初始化 mode, title 只是名稱可以更改  ###隱性轉換\n#include \u0026lt;SFML/Window.hpp\u0026gt;int main(){ int x = int(10.5); // double 可轉隱性轉型成int  sf::String title = \u0026#34;Hello\u0026#34;; // sf::String::String(\u0026#34;Hello\u0026#34;)  sf::Window w(sf::VideoMode(400, 200), title ); while(true){ } return 0; } 呼叫函式 #include \u0026lt;SFML/Window.hpp\u0026gt;int main(){ sf::Window w(sf::VideoMode(400, 200), \u0026#34;Hello\u0026#34;); while(w.isOpen()){ sf::Event evt; //參考不能傳匿名的物件  if (w.pollEvent(evt)) { //evt 存放著使用者互動發生的事件  if (evt.type == sf::Event::Closed) { std::cout \u0026lt;\u0026lt; \u0026#34;close\u0026#34; \u0026lt;\u0026lt; std::endl; w.close(); } } w.display(); } return 0; } 想對視窗做事??! #include \u0026lt;SFML/Window.hpp\u0026gt;int main(){ sf::RenderWindow w(sf::VideoMode(400, 200), \u0026#34;Hello\u0026#34;); while(w.isOpen()){ sf::Event evt; //參考不能傳匿名的物件  if (w.pollEvent(evt)) { //evt 存放著使用者互動發生的事件  if (evt.type == sf::Event::Closed) { std::cout \u0026lt;\u0026lt; \u0026#34;close\u0026#34; \u0026lt;\u0026lt; std::endl; w.close(); } } sf::Font font; font.loadFromFile(\u0026#34;arial.ttf\u0026#34;); sf::Text text(\u0026#34;Hello\u0026#34;, font); w.draw(text); w.display(); } return 0; }   用text的建構 =\u0026gt;要給字串 和字型 為了產生字型\n 用Font()建構 再loadFromFile()\r因為Font()第二個建構原本就要有字型了\r   sf::RenderWindow 在 Graphics.hpp 裡面\n  #include \u0026lt;SFML/Window.hpp\u0026gt;int main(){ sf::RebderWindow w(sf::VideoMode(400, 200), \u0026#34;Hello\u0026#34;); sf::Font font; if(font.loadFromFile(\u0026#34;arial.ttf\u0026#34;) == false ){ return 1; } //優化 字形只要產生一次不然每輪迴圈都要產生一次  sf::Text text(\u0026#34;Hello\u0026#34;, font); //文字也是一次  while(w.isOpen()){ sf::Event evt; //參考不能傳匿名的物件  if (w.pollEvent(evt)) { //evt 存放著使用者互動發生的事件  if (evt.type == sf::Event::Closed) { std::cout \u0026lt;\u0026lt; \u0026#34;close\u0026#34; \u0026lt;\u0026lt; std::endl; w.close(); } } w.draw(text); w.display(); } return EXIT_SUCCESS; }  增加if去讀讀看有沒有load到字型 return 通常是正常結束 return 1 = return EXIT_FAILTURE return 0 = return EXIT_SUCCESS  #include \u0026lt;SFML/Window.hpp\u0026gt;int main(){ sf::RebderWindow w(sf::VideoMode(400, 200), \u0026#34;Hello\u0026#34;); sf::Font font; if(font.loadFromFile(\u0026#34;arial.ttf\u0026#34;) == false ){ return 1; } //優化 字形只要產生一次不然每輪迴圈都要產生一次  sf::Text text(\u0026#34;Hello\u0026#34;, font); //文字也是一次  while(w.isOpen()){ sf::Event evt; //參考不能傳匿名的物件  if (w.pollEvent(evt)) { //evt 存放著使用者互動發生的事件  if (evt.type == sf::Event::Closed) { std::cout \u0026lt;\u0026lt; \u0026#34;close\u0026#34; \u0026lt;\u0026lt; std::endl; w.close(); } } w.clear(); // 清掉  w.draw(text); w.display(); text.move(0.01,0); // move 吃float  } return EXIT_SUCCESS; } ","permalink":"https://ycl818.github.io/blog/sfml/","tags":["coding"],"title":"SFML 1"},{"categories":["祝賀"],"contents":"今天我大Alex生日 Happy Birthday 這個效果OK吧,Alex Chen, 11/13 天蠍座\n 運勢非常旺，心想事成，許願都容易實現，而且運勢也相當不錯，喜歡的人事物都會因為你的招喚而來到眼前。感情方面容易一見锺情，你對他有意思他也會注意到你的存在，進展滿順利。幸運色是黑色。\n 唐老師星座運勢\n我們來回顧一下 Alex Chen 的 Wings of Piano   ","permalink":"https://ycl818.github.io/blog/%E9%99%B3%E5%82%91%E8%81%96%E7%94%9F%E6%97%A5%E5%BF%AB%E6%A8%82/","tags":["HBD","Scorpio"],"title":"Happy Birthday to Alex Chen"}]